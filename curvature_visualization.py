
"""
Spacetime Curvature Visualization Script
Visualizes the curvature data generated by the C++ black hole program
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.animation as animation
from matplotlib.colors import LogNorm

def load_curvature_data(filename='spacetime_data_curvature.txt'):
    """Load curvature data from the C++ program output"""
    try:
        # Skip comment lines starting with #
        data = []
        with open(filename, 'r') as f:
            for line in f:
                if not line.startswith('#') and line.strip():
                    values = list(map(float, line.strip().split()))
                    if len(values) == 4:
                        data.append(values)
        
        if not data:
            print(f"No data found in {filename}")
            return None
            
        data = np.array(data)
        return data[:, 0], data[:, 1], data[:, 2], data[:, 3]  # x, y, z, curvature
        
    except FileNotFoundError:
        print(f"File {filename} not found. Make sure to run the C++ program first.")
        return None
    except Exception as e:
        print(f"Error loading data: {e}")
        return None

def plot_3d_curvature(x, y, z, curvature):
    """Create a 3D scatter plot of spacetime curvature"""
    fig = plt.figure(figsize=(15, 10))
    
    # Main 3D plot
    ax1 = fig.add_subplot(221, projection='3d')
    
    # Filter out very small curvature values for better visualization
    mask = curvature > np.max(curvature) * 0.01
    x_filtered = x[mask]
    y_filtered = y[mask]
    z_filtered = z[mask]
    curv_filtered = curvature[mask]
    
    scatter = ax1.scatter(x_filtered, y_filtered, z_filtered, 
                         c=curv_filtered, cmap='plasma', 
                         alpha=0.6, s=20, norm=LogNorm())
    
    ax1.set_xlabel('X (Schwarzschild radii)')
    ax1.set_ylabel('Y (Schwarzschild radii)')
    ax1.set_zlabel('Z (Schwarzschild radii)')
    ax1.set_title('3D Spacetime Curvature')
    
    # Add black hole representation
    u = np.linspace(0, 2 * np.pi, 50)
    v = np.linspace(0, np.pi, 50)
    x_sphere = 2 * np.outer(np.cos(u), np.sin(v))  # Schwarzschild radius = 2
    y_sphere = 2 * np.outer(np.sin(u), np.sin(v))
    z_sphere = 2 * np.outer(np.ones(np.size(u)), np.cos(v))
    ax1.plot_surface(x_sphere, y_sphere, z_sphere, alpha=0.3, color='black')
    
    plt.colorbar(scatter, ax=ax1, label='Curvature', shrink=0.8)
    
    # XY plane slice (z=0)
    ax2 = fig.add_subplot(222)
    z_slice_mask = np.abs(z) < 0.5
    scatter2 = ax2.scatter(x[z_slice_mask], y[z_slice_mask], 
                          c=curvature[z_slice_mask], cmap='plasma', 
                          alpha=0.7, s=30, norm=LogNorm())
    
    # Add event horizon circle
    theta = np.linspace(0, 2*np.pi, 100)
    event_horizon_x = 2 * np.cos(theta)
    event_horizon_y = 2 * np.sin(theta)
    ax2.plot(event_horizon_x, event_horizon_y, 'k-', linewidth=2, label='Event Horizon')
    
    ax2.set_xlabel('X (Schwarzschild radii)')
    ax2.set_ylabel('Y (Schwarzschild radii)')
    ax2.set_title('Curvature in XY Plane (z≈0)')
    ax2.set_aspect('equal')
    ax2.legend()
    plt.colorbar(scatter2, ax=ax2, label='Curvature')
    
    # Radial curvature profile
    ax3 = fig.add_subplot(223)
    r = np.sqrt(x**2 + y**2 + z**2)
    
    # Bin by radius for cleaner plot
    r_bins = np.linspace(2.5, 20, 50)
    r_centers = (r_bins[:-1] + r_bins[1:]) / 2
    curvature_profile = []
    
    for i in range(len(r_bins)-1):
        mask = (r >= r_bins[i]) & (r < r_bins[i+1])
        if np.any(mask):
            curvature_profile.append(np.mean(curvature[mask]))
        else:
            curvature_profile.append(0)
    
    ax3.semilogy(r_centers, curvature_profile, 'b-', linewidth=2, marker='o')
    ax3.axvline(x=2, color='red', linestyle='--', linewidth=2, label='Schwarzschild Radius')
    ax3.axvline(x=6, color='orange', linestyle='--', linewidth=1, label='Photon Sphere (3Rs)')
    
    ax3.set_xlabel('Radius (Schwarzschild radii)')
    ax3.set_ylabel('Average Curvature')
    ax3.set_title('Radial Curvature Profile')
    ax3.grid(True, alpha=0.3)
    ax3.legend()
    
    # Curvature histogram
    ax4 = fig.add_subplot(224)
    ax4.hist(np.log10(curvature[curvature > 0]), bins=50, alpha=0.7, color='purple')
    ax4.set_xlabel('log₁₀(Curvature)')
    ax4.set_ylabel('Frequency')
    ax4.set_title('Curvature Distribution')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

def create_curvature_animation(x, y, z, curvature):
    """Create an animated visualization rotating around the black hole"""
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # Filter data for animation performance
    mask = curvature > np.max(curvature) * 0.05
    x_anim = x[mask]
    y_anim = y[mask]
    z_anim = z[mask]
    curv_anim = curvature[mask]
    
    def animate(frame):
        ax.clear()
        
        # Rotate view
        ax.view_init(elev=20, azim=frame * 2)
        
        # Plot curvature data
        scatter = ax.scatter(x_anim, y_anim, z_anim, 
                           c=curv_anim, cmap='plasma', 
                           alpha=0.6, s=25, norm=LogNorm())
        
        # Add black hole sphere
        u = np.linspace(0, 2 * np.pi, 20)
        v = np.linspace(0, np.pi, 20)
        x_sphere = 2 * np.outer(np.cos(u), np.sin(v))
        y_sphere = 2 * np.outer(np.sin(u), np.sin(v))
        z_sphere = 2 * np.outer(np.ones(np.size(u)), np.cos(v))
        ax.plot_surface(x_sphere, y_sphere, z_sphere, alpha=0.4, color='black')
        
        ax.set_xlabel('X (Schwarzschild radii)')
        ax.set_ylabel('Y (Schwarzschild radii)')
        ax.set_zlabel('Z (Schwarzschild radii)')
        ax.set_title(f'Rotating View - Frame {frame}')
        
        # Set consistent axis limits
        ax.set_xlim([-15, 15])
        ax.set_ylim([-15, 15])
        ax.set_zlim([-15, 15])
    
    anim = animation.FuncAnimation(fig, animate, frames=180, interval=50, blit=False)
    plt.show()
    return anim

def plot_spacetime_embedding(x, y, z, curvature):
    """Create a 2D embedding diagram showing spacetime curvature"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))
    
    # Create a 2D grid for the embedding diagram
    r_max = 15
    r = np.linspace(2.1, r_max, 100)  # Start just outside event horizon
    theta = np.linspace(0, 2*np.pi, 100)
    R, THETA = np.meshgrid(r, theta)
    
    # Calculate embedding surface height (simplified)
    # This represents the "rubber sheet" analogy
    height = -4 * np.sqrt(2 / R)  # Simplified embedding equation
    
    X_embed = R * np.cos(THETA)
    Y_embed = R * np.sin(THETA)
    
    # 3D embedding surface
    ax1 = plt.subplot(121, projection='3d')
    surface = ax1.plot_surface(X_embed, Y_embed, height, cmap='viridis', alpha=0.7)
    
    # Add event horizon
    r_eh = 2.0
    theta_eh = np.linspace(0, 2*np.pi, 50)
    x_eh = r_eh * np.cos(theta_eh)
    y_eh = r_eh * np.sin(theta_eh)
    z_eh = np.zeros_like(x_eh)
    ax1.plot(x_eh, y_eh, z_eh, 'r-', linewidth=3, label='Event Horizon')
    
    ax1.set_xlabel('X')
    ax1.set_ylabel('Y')
    ax1.set_zlabel('Spacetime Curvature')
    ax1.set_title('Spacetime Embedding Diagram')
    ax1.legend()
    
    # 2D contour plot
    ax2 = plt.subplot(122)
    
    # Create 2D grid of curvature values
    grid_x = np.linspace(-15, 15, 100)
    grid_y = np.linspace(-15, 15, 100)
    X_grid, Y_grid = np.meshgrid(grid_x, grid_y)
    
    # Interpolate curvature values onto grid
    from scipy.interpolate import griddata
    
    # Use only z=0 plane data for 2D visualization
    z_plane_mask = np.abs(z) < 1.0
    if np.any(z_plane_mask):
        points = np.column_stack((x[z_plane_mask], y[z_plane_mask]))
        values = curvature[z_plane_mask]
        
        curvature_grid = griddata(points, values, (X_grid, Y_grid), method='cubic', fill_value=0)
        
        # Create contour plot
        contour = ax2.contourf(X_grid, Y_grid, curvature_grid, levels=20, cmap='plasma', norm=LogNorm())
        contour_lines = ax2.contour(X_grid, Y_grid, curvature_grid, levels=10, colors='white', alpha=0.5, linewidths=0.5)
        
        # Add event horizon circle
        circle = plt.Circle((0, 0), 2, fill=False, color='red', linewidth=2, label='Event Horizon')
        ax2.add_patch(circle)
        
        # Add photon sphere
        photon_sphere = plt.Circle((0, 0), 3, fill=False, color='orange', linewidth=1, linestyle='--', label='Photon Sphere')
        ax2.add_patch(photon_sphere)
        
        plt.colorbar(contour, ax=ax2, label='Curvature')
        ax2.set_xlabel('X (Schwarzschild radii)')
        ax2.set_ylabel('Y (Schwarzschild radii)')
        ax2.set_title('Curvature Contour Map')
        ax2.set_aspect('equal')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()

def analyze_light_bending():
    """Generate visualization showing how light rays bend around the black hole"""
    fig, ax = plt.subplots(figsize=(12, 8))
    
    # Define light ray paths at different impact parameters
    impact_parameters = [2.5, 3.0, 4.0, 6.0, 8.0, 10.0]
    colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple']
    
    for i, b in enumerate(impact_parameters):
        # Simplified light ray trajectory calculation
        # This is a simplified model - the full calculation requires solving geodesics
        
        # Starting position (far left)
        x_start = -15
        y_start = b
        
        # Ray approaches from left
        x_ray = []
        y_ray = []
        
        # Trace ray path (simplified)
        x = x_start
        dx = 0.1
        
        while x < 15:
            r = np.sqrt(x**2 + y_start**2)
            
            if r < 2.1:  # Ray hits black hole
                break
                
            # Simple deflection angle calculation (weak field approximation)
            deflection = 4 / b * (1 / np.sqrt(x**2 + b**2))
            y_deflected = y_start - deflection * (x - x_start) / 10
            
            x_ray.append(x)
            y_ray.append(y_deflected)
            x += dx
        
        ax.plot(x_ray, y_ray, color=colors[i], linewidth=2, 
                label=f'Impact parameter = {b:.1f}')
        
        # Plot symmetric ray (below x-axis)
        y_ray_sym = [-y for y in y_ray]
        ax.plot(x_ray, y_ray_sym, color=colors[i], linewidth=2, alpha=0.7)
    
    # Add black hole and important radii
    circle_bh = plt.Circle((0, 0), 2, fill=True, color='black', label='Black Hole (Event Horizon)')
    circle_ps = plt.Circle((0, 0), 3, fill=False, color='red', linestyle='--', linewidth=2, label='Photon Sphere')
    ax.add_patch(circle_bh)
    ax.add_patch(circle_ps)
    
    ax.set_xlim(-15, 15)
    ax.set_ylim(-12, 12)
    ax.set_xlabel('X (Schwarzschild radii)')
    ax.set_ylabel('Y (Schwarzschild radii)')
    ax.set_title('Light Ray Bending Around Black Hole')
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.legend()
    
    plt.tight_layout()
    plt.show()

def main():
    """Main function to run all visualizations"""
    print("Spacetime Curvature Visualization")
    print("=" * 40)
    
    # Load data
    print("Loading curvature data...")
    data = load_curvature_data()
    
    if data is None:
        print("Could not load curvature data. Please run the C++ program first.")
        return
    
    x, y, z, curvature = data
    print(f"Loaded {len(x)} data points")
    print(f"Curvature range: {np.min(curvature):.6f} to {np.max(curvature):.6f}")
    
    # Create visualizations
    print("\n1. Creating 3D curvature visualization...")
    plot_3d_curvature(x, y, z, curvature)
    
    print("\n2. Creating spacetime embedding diagram...")
    try:
        plot_spacetime_embedding(x, y, z, curvature)
    except ImportError:
        print("Scipy not available - skipping embedding diagram")
        print("Install with: pip install scipy")
    
    print("\n3. Creating light ray bending visualization...")
    analyze_light_bending()
    
    print("\n4. Creating animated rotation...")
    try:
        anim = create_curvature_animation(x, y, z, curvature)
        print("Animation created. Close the window to continue.")
    except Exception as e:
        print(f"Animation failed: {e}")
    
    print("\nAll visualizations complete!")

if __name__ == "__main__":
    # Check for required packages
    required_packages = ['numpy', 'matplotlib']
    missing_packages = []
    
    for package in required_packages:
        try:
            __import__(package)
        except ImportError:
            missing_packages.append(package)
    
    if missing_packages:
        print("Missing required packages:", missing_packages)
        print("Install with: pip install", " ".join(missing_packages))
    else:
        main()